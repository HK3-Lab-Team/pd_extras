from typing import Any, Dict, Iterable, Tuple, Union

import sklearn

from .feature_enum import EncodingFunctions, OperationTypeEnum


def _to_tuple(x: Union[str, Iterable]) -> Tuple:
    """
    Transform input into a tuple.

    This function transforms the input ``x`` into a tuple avoiding to interpret a
    string as a tuple of characters.
    In case ``x`` is None, the function returns None.

    Parameters
    ----------
    x: Union[str, Iterable]
        The variable that needs to be transformed to tuple

    Returns
    -------
    Tuple
        If the input ``x`` is list/set, ``x`` is cast to tuple and returned. Otherwise
        a tuple containing ``x`` element only is returned.
    """
    if isinstance(x, tuple):
        return x
    elif isinstance(x, list) or isinstance(x, set):
        return tuple(x)
    elif x is None:
        return None
    else:
        return tuple([x])


class FeatureOperation:
    """
    This is a Class to store the operations executed on df.
    """

    def __init__(
        self,
        operation_type: OperationTypeEnum,
        original_columns: Union[Tuple[str], str, None] = (),
        derived_columns: Union[Tuple[str], str, None] = (),
        encoded_values_map: Union[Dict[int, Any], None] = None,
        encoder: sklearn.preprocessing._encoders._BaseEncoder = None,
        details: Union[Dict, None] = None,
    ):
        """
        Model to store the operations executed on a DataFrameWithInfo instance

        Parameters
        ----------
        operation_type: OperationTypeEnum
            OperationTypeEnum value that describes the type of the operation performed.
        original_columns: Union[Tuple[str], str, None], optional
            Tuple of the columns that were used as input for the operation performed.
            When set to None, it means that the attribute is not
            defined and it can be used when looking for a FeatureOperation, whose
            original columns are unknown. Default set to ().
        derived_columns: Union[Tuple[str], str, None], optional
            Tuple of the columns that were generated as output after performing the
            operation. If this tuple is equal to original_columns, it will be
            reassigned to (). When set to None, it means that the attribute is not
            defined and it can be used when looking for a FeatureOperation, whose
            derived columns are unknown. Default set to ().
        encoded_values_map: Union[Dict[int, Any], None], optional
            Map that connects the ``derived_columns`` values, generated by an
            encoding operation, to the represented values (of the
            ``original_columns``). Default set to None
        encoder: sklearn.preprocessing._encoders._BaseEncoder, optional
            Sklearn.preprocessing encoder instance that has been used for encoding.
            This should be an instance of one the classes listed in
            ``EncodingFunctions`` Enum. This may be useful to reverse the encoding.
        details: Dict, optional
            Dict containing details about the operation, like the map between encoded
            value and original value. It may be set to None
        """
        # This is to avoid that a single column (i.e. a string) is interpreted as a
        # tuple of single chars
        original_columns = _to_tuple(original_columns)
        derived_columns = _to_tuple(derived_columns)

        self.original_columns = original_columns
        self.operation_type = operation_type

        # TODO: Maybe remove this (because the value in docstring is the same
        #  as encoded_values_map
        self.details = details

        encoding_functions_values = [e.value for e in EncodingFunctions]
        if encoder is None or type(encoder) in encoding_functions_values:
            # TODO: Remove one of these following two
            #  (or maybe just distinguish between the instance and the
            #  class type...maybe not!):
            self.encoder = encoder
            self.encoding_function = encoder
        else:
            raise NotImplementedError(
                f"The encoder {encoder} is not yet supported "
                f"by the library. Possible values are: {encoding_functions_values}"
            )

        if encoded_values_map is None:
            self.encoded_values_map = {}
        else:
            self.encoded_values_map = encoded_values_map

        if derived_columns == original_columns and original_columns is not None:
            self.derived_columns = ()
        else:
            self.derived_columns = derived_columns

    @property
    def encoded_string_values_map(self) -> Union[Dict[int, str], None]:
        """
        This is a modified version of the attribute 'self.encoded_values_map'
        where we want string values instead of tuples
        """
        if self.encoded_values_map is None:
            return None
        else:
            encoded_string_values_map = {}
            for key, value in self.encoded_values_map.items():
                if not isinstance(value, str):
                    encoded_string_values_map[key] = "-".join(str(x) for x in value)
                else:
                    encoded_string_values_map[key] = value
            return encoded_string_values_map

    def __eq__(self, other) -> bool:
        """
        Compare two FeatureOperation instances to check if they are equal.

        This is useful when we want to compare two FeatureOperation instances (used in
        method 'find_operation_in_column').
        This allows some attributes not to be explicit, if they are set to None.
        In that case the attribute is considered "not specified" and it is not
        considered in the equality check.
        Therefore the conditions for the two instances to be considered equal are:
        1. Same ``operation_type`` attribute
        2. Each of the attributes ``original_columns``, ``derived_columns``
        and ``encoder`` is compared between the two instances and it is considered
        equal when:
            a. In at least one of the two instance is None,
            b. Or has the same value

        Parameters
        ----------
        other: FeatureOperation
            The instance that is compared with self

        Returns
        -------
        bool
            True if all the conditions above are fulfilled and False otherwise
        """
        if isinstance(other, self.__class__):
            if (
                self.operation_type == other.operation_type
                and (
                    self.original_columns is None
                    or other.original_columns is None
                    or set(self.original_columns) == set(other.original_columns)
                )
                and (
                    self.derived_columns is None
                    or other.derived_columns is None
                    or set(self.derived_columns) == set(other.derived_columns)
                )
                and (
                    self.encoder is None
                    or other.encoder is None
                    or isinstance(self.encoder, type(other.encoder))
                )
            ):
                return True
        return False

    def __str__(self):
        return (
            f"Columns used to produce the result: {self.original_columns}"
            + f"\nType of the operation that has been applied: {self.operation_type}"
            + f"\nColumns created after the operation: {self.derived_columns}"
            + f"\nMap between original values and encoded ones: \n{self.encoded_values_map}"
            + (
                f"\nEncoding function used: {self.encoding_function}"
                if self.encoding_function
                else ""
            )
        )
